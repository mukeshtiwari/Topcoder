<html>
<head>
    <title>SwappingNodes</title>
</head>
<body>
<h1><a href="/tc?module=ProblemDetail&amp;rd=17426&amp;pm=15335">SwappingNodes</a></h1>

<p><em>2019 Humblefool Cup Prelims - Division I, Level One</em></p>

<h2>Statement</h2>

<p>We have a full binary tree.
That is, we have a rooted tree in which all leaves have the same depth, and each node that is not a leaf has exactly one left child and one right child.
Each leaf of our tree contains a positive integer, and these integers are distinct.</p>

<p>As an example, the figure below shows a full binary tree with four leaves:</p>

<p><strong><strong><strong><strong>C</strong></strong></strong></strong>
                             /                 \
                        <strong><strong>A</strong></strong>           <strong><strong>B</strong></strong>
                       /         \         /         \
              5       2       1           3</p>

<p>You are given the int[] <em>leaves</em>: the values that are currently stored in the leaves of the tree, read from the left to the right.
For example, for the tree shown above you would be given <em>leaves</em> = {5, 2, 1, 3}.</p>

<p>For your convenience, you are also given the int <em>numberOfLeaves</em>.
Its value will be equal to the number of elements in <em>leaves</em>.</p>

<p>You are allowed to transform our tree by performing a sequence of steps.
In each step you can select any inner node of the tree and swap its left and right subtrees.
(That is, the left child of the selected node becomes its right child and vice versa.)
You may do arbitrarily many steps, including zero.
You may choose the same node multiple times if you wish.</p>

<p>After you are done transforming the tree, we are going to read the values stored in its leaves (again, from the left to the right).
Your task is to make this sequence as small as possible.
Compute and return the lexicographically smallest sequence that can be constructed in the leaves of the tree.
(See Notes for the definition of "lexicographically smaller".)</p>

<h2>Definitions</h2>

<ul>
<li><em>Class</em>: <code>SwappingNodes</code></li>
<li><em>Method</em>: <code>swapNodes</code></li>
<li><em>Parameters</em>: <code>int[], int</code></li>
<li><em>Returns</em>: <code>int[]</code></li>
<li><em>Method signature</em>: <code>int[] swapNodes(int[] leaves, int numberOfLeaves)</code></li>
</ul>


<h2>Notes</h2>

<ul>
<li>Given two distinct sequences A = a0,a1,....an-1 and B = b0,b1,....bn-1, the lexicographically smaller sequence is the one that has a smaller value at the first index where they differ. In other words, the sequence A is smaller than the sequence B if for some index x we have (ax &lt; bx) and (for all i &lt; x : ai = bi).</li>
</ul>


<h2>Constraints</h2>

<ul>
<li><em>leaves</em> will have between 1 and 512 elements, inclusive.</li>
<li>The number of elements in <em>leaves</em> will be a power of 2.</li>
<li>Each element of <em>leaves</em> will be between 1 and 512, inclusive.</li>
<li>All values of <em>leaves</em> will be distinct.</li>
<li><em>numberOfLeaves</em> will be equal to the number of elements in <em>leaves</em>.</li>
</ul>


<h2>Examples</h2>

<h3>Example 1</h3>

<h4>Input</h4>

<p><c>[5,2,1,3],<br />4</c></p>

<h4>Output</h4>

<p><c>[1, 3, 2, 5 ]</c></p>

<h4>Reason</h4>

<p>The input describes the tree shown in the problem statement.</p>

<p>One optimal solution looks as follows:</p>

<p>Select node C and swap its subtrees. This produces a tree that corresponds to the sequence {1, 3, 5, 2}.
Then, select node A and swap its subtrees. (Note that A is currently the right child of C.) This produces a tree that corresponds to the sequence {1, 3, 2, 5}.</p>

<p>The sequence {1, 3, 2, 5} is the lexicographically smallest of all sequences that can be produced by transforming the tree, and therefore this is the correct return value.</p>

<h3>Example 2</h3>

<h4>Input</h4>

<p><c>[13, 10, 18, 16],<br />4</c></p>

<h4>Output</h4>

<p><c>[10, 13, 16, 18 ]</c></p>

<h4>Reason</h4>

<p>Here, one optimal solution looks as follows:</p>

<p>Select the left child of the root of the tree. New sequence: {10, 13, 18, 16}.
Then, select the right child of the root of the tree. New sequence: {10, 13, 16, 18}.</p>

<p>Obviously, the sequence we just produced has to be optimal, so we are done.</p>

</body>
</html>
